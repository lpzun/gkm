#include <iostream>
#include <ctime>
#include <string>
#include <string.h>

#include "bp.hh"
#include "file.hh"
#include "ttd.hh"

enum InputType{BP, TTD};

int main(int argc, char *argv[])
{
	if( argc<=1 ||strcmp(argv[1], "-h")==0)
	{
		//print helps
		cout << "\nusage: " << argv[0] << "-bfs -km -star b -graph f -thread n -ttd\n";
		cout << "-ttd	= specify input as ThreadState Transition Diagram instead of Boolean Programs.\n";
		cout << "-star	= replace all non-deterministic * with either only 0 or 1 (in BP only).\n";
		cout << "-ts	= print all generated thread states.\n";
		cout << "-bfs	= perform the exploration in Breath-first fashion (but not with the fastest algorithm).\n";
		cout << "-dfs	= perform the exploration in Depth-first fashion (but not with the fastest algorithm).\n";
		cout << "-km	= perform complete exploration i.e.use Karp & Miller's original algorithm.\n";
		cout << "-graph	= output the generated coverability tree to a dot format.\n";
		cout << "-thread	= initialize the exploration with n thread (infinite in default).\n";		
		cout << "\n\nTerms we use in the results:\n";
		cout << "\nExplored Configuration::\nthe configurations we have explored, including the configuration we found invalid.\n";
		cout << "\nConfiguration Stored::\nthe configurations we actually stored in the memory and the graph.\n";
		cout << "\nThread State::\nthe thread states generated by the procedure.\n";
		return true;
	}

	std::string fileName(argv[1]);

	InputType inputType = BP; // the default type of input program is Boolean Program
	ast::constant::trival non_determinitic = ast::constant::STAR;
	
	bool algorithmKM = false;
	bool depthFirst = true;
	bool fast = false;
	unsigned numThread = 0;
	std::string graph = std::string("");
	for(int i = 1; i< argc; i++)
	{
		if (strcmp(argv[i], "-ttd")==0) //specify the type of input program to ThreadState Transition Diagram
			inputType = TTD;

		if (strcmp(argv[i], "-km")==0) //use Karp Miller's algorithm
			algorithmKM = true;
		
		if (strcmp(argv[i], "-dfs")==0) //use Karp Miller's algorithm
			depthFirst = true;
		
		if (strcmp(argv[i], "-bfs")==0) //seach in breath first search fashion
			depthFirst = false;

		if (strcmp(argv[i], "-fast")==0) //seach in breath first search fashion
			fast = true;
		
		if (strcmp(argv[i], "-graph")==0) // output the tree to a dot graph
			 graph= std::string(argv[++i]);
			
		if (strcmp(argv[i], "-thread")==0) // output the tree to a dot graph
			 numThread = atoi(argv[++i]);
		
		if (strcmp(argv[i], "-star")==0) // specify non-deterministic value
			non_determinitic = ast::constant::trival(atoi(argv[++i]));
	}
	
	if(inputType == BP)
	{
		//initialize the system
		context ctx;
		if (!ctx.parse (removeComment(fileName).c_str()))
		{
			cout << "Unable to open file";
			exit(1); // terminate with error
		}

		BP_AdditionSet* additionSet = new BPInterpretator(*(ast::program*)ctx.result,non_determinitic);
		delete ctx.result;

		BP_Config* initConfig = *additionSet->getInitialConfigs(numThread).begin();
		BP_System system(additionSet);
		
		//std::cout << ((BPInterpretator*)additionSet)->numOfshared() << " "
			//<< ((BPInterpretator*)additionSet)->numOflocal() << std::endl;
		//return 0;	

		clock_t start,finish;
		start=clock();
			
		system.graphFile = graph;
		system.coverability(initConfig, algorithmKM, depthFirst, fast);

		finish=clock();

		for(int i = 1; i< argc; i++)
		{
			if (strcmp(argv[i], "-ts")==0)
			{
				std::cout << "The explored thread states: ( formatted as [";
				((BPInterpretator*)additionSet)->printSharedVars(std::cout<<"(");
				((BPInterpretator*)additionSet)->printLocalVars(std::cout << "),(");
				std::cout <<",PC)]\n\n";

				system.outputThreadStates(std::cout);std::cout << std::endl;
				std::cout << std::endl;
			}
		}
		
		((BPInterpretator*)additionSet)->printLocalStatesStat(std::cout);
		
		std::list<std::list<BP_Config*> > configPtrSet = system.configPtrCollection->ptrCollection;
		
		unsigned max = 0, min = 0, total = 0, counts = 0;
		std::list<std::list<BP_Config*> >::iterator outer;
		for(outer = configPtrSet.begin(); outer != configPtrSet.end(); outer++)
			if(outer->size() > 0)
				for(std::list<BP_Config*>::iterator inner = outer->begin(); inner!= outer->end(); inner++)
				{
					counts++;
					total+=(*inner)->counters.size();
					if (min == 0 || min > (*inner)->counters.size())
						min = (*inner)->counters.size();
					if (max < (*inner)->counters.size())
						max = (*inner)->counters.size();
				}
		cout << "#Nonzeros, Max:" << max << " Min:" << min <<" Avg:" << total/counts << std::endl;
		cout << "#Explored configurations: " << system.numOfExploredNode() << std::endl;
		cout << "#Configurations Stored(unique): " << system.numOfConfig() << std::endl;
		cout << "#Thread states: " << system.numOfThreadState() << std::endl;
		cout << "Time cost: " << (double)(finish-start)/CLOCKS_PER_SEC << " sec." << endl;
	}

	if(inputType == TTD)
	{
		//initialize the system
		TransitionSet* additionSet = new TransitionSet(removeComment(fileName).c_str());
		TTD_Config* initConfig = *additionSet->getInitialConfigs(numThread).begin();
		TTD_System system(additionSet);
		clock_t start,finish;
		start=clock();

		system.graphFile = graph;
		system.coverability(initConfig, algorithmKM, depthFirst, fast);

		finish=clock();

		for(int i = 1; i< argc; i++)
		{
			if (strcmp(argv[i], "-ts")==0)
			{
				std::cout << "The explored thread states:\n";
				system.outputThreadStates(std::cout);std::cout << std::endl;
				std::cout << std::endl;
			}
		}
		
		cout << "#Explored nodes: " << system.numOfExploredNode()<<std::endl;
		cout << "#Configurations Stored: " << system.numOfConfig() << std::endl;
		cout << "#Thread states: " << system.numOfThreadState() << std::endl;
		cout << "Time cost: " << (double)(finish-start)/CLOCKS_PER_SEC << " sec." << endl;

	}
};

